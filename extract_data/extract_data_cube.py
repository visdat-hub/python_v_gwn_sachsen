## @package Extract data from ndimensional data cubes (ndarray)
#
# Dimensions are x (col), y (row) and t (time)
# Usage
# ----------
# cd /mnt/visdat/Projekte/2020/GWN Viewer/dev/python/extract_data/
#
# python3 extract_data.py -src_folder /var/rosi_data/daten_stb/gwn_sachsen/ -data_type kliwes -scenario_id 0 -level_id 1 -area_id 12 -area_data [1,2,3] -parameter_id 10 -years [1960,1990] -output map_data
#
# Command line arguments
# ----------
# - src_folder : string, folder of h5 data generated by create_import_structure
# - data_type : string, kliwes, difga, raklida_messungen, raklida_referenz, raklida_wettreg66
# - scneario_id : integer, scenario identifier
# - parameter_id : integer, identifier of parameter to extract
# - level_id : integer, level identifier to set spatial resolution
#   - level 1 : 100m
#   - level 2 : 50m
#   - level 3 : 25m
# - area_id : integers, area identifier
# - area_data : int array, identifiers of area (polygon) data, or, if none/all is selected []
# - years : int array, [start_year, last_year]
# - output: string, type of output data --> map_data, base_statistic, histogram, timeline

import sys
import os
import h5py
import pandas as pd
import numpy as np
sys.path.append('/mnt/visdat/Projekte/2020/GWN viewer/dev/python/extract_data/pg')
from pg import db_connector as pg

class extract_data_cube:
    ## @brief Define database configurationma
    def __init__(self):
        """ """
        # define database access
        self.conf = {'dbconfig' :
            {
                "db_host" : "192.168.0.194",
                "db_name" : "gwn_sachsen",
                "db_user" : "visdat",
                "db_password" : "9Leravu6",
                "db_port" : "9991"
            }
        }
        print(os.getcwd())
        # placeholder, set final decimal in function check_parameter_file()
        self.decimals = 0

    ## @brief Get command line arguments.
    #
    # @returns args Array of arguments
    def get_arguments(self, defs, modul):

        print("--> get caller arguments")
        args = {
            'id_level' : 1,
            'id_param' : defs['param']['id_param'],
            'id_scenario' : defs['param']['id_scenario'],
            'id_area' : defs['param']['id_area'],
            'id_areadata' : defs['param']['id_areadata'],
            'start_year' : defs['param']['time']['start_year'],
            'end_year' : defs['param']['time']['end_year'],
            'proj_dir' : defs['project']['proj_dir'],
            'stat_spec' : 'w_mean',
            'error' : 0
        }
        try:
            args['time_period'] =  defs['param']['time_period']
        except:
            args['time_period'] = 'year'

        try:
            args['start_month'] =  defs['param']['start_month']
        except:
            args['start_month'] = '0'

        try:
            args['end_month'] =  defs['param']['end_month']
        except:
            args['end_month'] = '0'

        try:
            args['group_area'] =  defs['param']['group_area']
        except:
            args['group_area'] = 0

        for p in args:
            if args[p] == None:
                print("ERROR: arguments of program call missing --> ", p)
                sys.exit()

        return args

    ## @brief Check if folder exists
    #
    # @param folder_list, list of folders to check
    def check_folder(self, folder_list):
        print('--> check folders')
        for f in folder_list:
            if not os.path.exists(f):
                sys.exit('ERROR: folder not exists --> ' + f)
            else:
                print('OK, folder found --> ', f)

    ## @brief Check if file exists
    #
    # @param args, command line arguments
    # @returns fname string, file name
    def check_area_file(self, args):
        print('--> check area filename')
        # variables
        fname = None
        fpath = None
        path = args['proj_dir'] + '/areas/' + str(args['id_area']) + '/'
        fn = str(args['id_area']) + '_' + str(args['id_level'])

        # check if file exists
        if os.path.exists(path):
            for r, d, f in os.walk(path):
                for file in f:
                    if fn + '.' in file:
                        print('OK, file found ', file, 'in', path)
                        fname = file
        else:
            sys.exit('ERROR: path not found '+ path)

        if fname != None:
            fpath = path + fname
        else:
            sys.exit('ERROR: file not found '+ fn)

        return fpath

    ## @brief Check if file exists
    #
    # @param args, command line arguments
    # @returns fname string, file name
    def check_parameter_file(self, args):
        print('--> check parameter filename')
        # variables
        fname = None
        fpath = None
        path = args['proj_dir'] + '/parameters/'  + str(args['id_scenario']) + '/' + str(args['id_param']) + '/'
        fn = str(args['id_param']) + '_' + str(args['id_scenario']) + '_' + str(args['id_level'])

        print('--> path :', path)
        print('--> fn :', fn)

        # check if file exists
        if os.path.exists(path):
            for r, d, f in os.walk(path):
                for file in f:
                    if fn + '.' in file:
                        print('OK, file found ', file, 'in', path)
                        fname = file
        else:
            return -1
            #sys.exit('ERROR: path not found '+ path)

        if fname != None:
            fpath = path + fname
        else:
             return -1
            #sys.exit('ERROR: file not found '+ fn)

        # set self.decimals
        self.decimals = int(fname.split('.')[2])

        return fpath
    
    ## @brief Check if file exists
    #
    # @param args, command line arguments
    # @returns fname string, file name
    def check_parameter_export_file(self, args):
        print('--> check parameter filename')
        path = args['proj_dir']+'parameters/'+str(args['id_scenario'])+'/'+str(args['id_param'])+'/map/'
        fn = str(args['id_param'])+'_'+str(args['id_scenario'])+'_1_'+str(args['start_year'])+'_'+str(args['end_year'])+'.int32.2.h5'
        param_export_fpath = path +fn
    
        print('--> path :', path)
        print('--> fn :', fn)

        if os.path.exists(param_export_fpath) != True:
            exists = 0
        else:
            exists = 1

        return exists, param_export_fpath

    def create_map_data(self, arg):
        
        print('--> parameter_fpath :', arg['parameter_fpath'])
        fn = arg['parameter_fpath']
        h5 = h5py.File(fn, 'r')
        #print('--> h5 :', h5)
        cube = h5['table']
        x = h5['x']
        y = h5['y']
        #print('--> cube :', cube)
        
        min_year = int(arg['start_year'])
        max_year = int(arg['end_year'])
        #print('--> min_year :', min_year)
        #print('--> max_year :', max_year)
        
        first_year_idx = np.argwhere(h5['year'][:] == min_year)[0][0]
        last_year_idx = np.argwhere(h5['year'][:] == max_year)[0][0]
        #print('first_year_idx --> ',first_year_idx, 'last_year_idx --> ', last_year_idx)
        # filter cube
        
        #print(cube.shape)
        data = cube[:,:,first_year_idx:last_year_idx+1].astype(float)
        # set nan
        data[data==-99999.0] = np.nan
        #print('--> data :', data)
        
        mean = np.nanmean(data, axis=2)
        #print(mean.shape, np.nanmean(mean))
        #print(np.nanmean(data))
        mean[np.isnan(mean)] = -99999.0
        
        #print(mean.shape, mean.dtype)
        #print('--> mean :', mean)
        
        data = np.flipud(mean)
        path = arg['param_export_fpath']
        print('--> path :', path)
        
        f = h5py.File(path, 'w')
        ds = f.create_dataset('Band1', (data.shape) , dtype=data.dtype)
        ds[:] = data
        f.create_dataset('x', data = x)
        f.create_dataset('y', data = y)
        f.close()

    ## @brief Calculate raster dataset as weighted mean over area and time
    #
    # @param args
    # @param paramter, 3-dimensional array
    # @param area, 2-dimensional array
    # @returns raster, 2-dimensional array
    def get_area_values(self, args, parameter, area):
        print('--> get area values')
        # get average over time
        mean = np.nanmean(parameter, axis=2)
        #print('--> area 1',area)
        #area = area.fillna(-9999)

        # get average over area
        df = pd.DataFrame(np.array([area.flatten(), mean.flatten()]).T)
        df = df.rename(columns={0:'area',1:'value'}).dropna()
        # df = df.rename(columns={0:'area',1:'value'}).drop(-99999)
        df_stat = df.groupby(['area']).max().round(0).astype(int).reset_index()
        #print('--> df_stat 1',df_stat)

        return df_stat

    ## @brief Calculate base statstics
    #
    # @param args
    # @param paramter, 3-dimensional array
    # @param area, 2-dimensional array
    # @returns df, pandas dataframe
    def get_base_statistic(self, args, parameter, area):
        print('--> get base statistic')
        # get average over time
        mean = np.nanmean(parameter, axis=2)
        #print(mean.shape, area.shape)

        df = pd.DataFrame(np.array([area.flatten(), mean.flatten()]).T)
        df = df.rename(columns={0:'area',1:'value'}).dropna()

        # drop values and areas < -99999.. -9999
        df = df[df['value']!=-99999]
        df = df[df['value']!=-9999]
        df = df[df['value']!=-999900]
        df = df[df['area']!=-99999]
        df = df[df['area']!=-9999]
        df = df[df['area']!=-999900]
        #print('--> df 3 :', df)

        df_stat = {}
        
        df_stat['mean'] = df['value'].mean()
        df_stat['min'] = df['value'].min()
        df_stat['max'] = df['value'].max()
        df_stat['median'] = df['value'].median()
        df_stat['std'] = df['value'].std()
        df_stat['sum'] = df['value'].sum()

        return df_stat


    ## @brief Calculate timeline for a set of areas
    #
    # @param args
    # @param paramter, 3-dimensional array
    # @param area, 2-dimensional array
    # @returns df, pandas dataframe
    def get_timeline(self, args, parameter, area, years):
        print('--> get timeline')
        # get average for each time period for 2d array
        mean = np.nanmean(parameter, axis=(0,1))
        df = pd.DataFrame([years, mean]).T
        df = df.rename(columns={0:'year', 1:'mean'})
        df['year'] = df['year'].astype(int)
        df['mean'] = (df['mean']).round(0).astype(int)
        #print(df)
        return df


    ## @brief Calculate histogram over a set of areas and time
    #
    # @param args
    # @param paramter, 3-dimensional array
    # @param area, 2-dimensional array
    # @returns df, pandas dataframe
    def get_histogram(self, args, parameter, area):
        
        print('--> get histogram')

        # get average over time
        mean = np.nanmean(parameter, axis=2).round(0)
        #print(mean)
        #print(mean.shape, area.shape)
        #print('min', np.nanmin(mean),'max', np.nanmax(mean))

        df = pd.DataFrame(np.array([area.flatten(), mean.flatten()]).T)
        df = df.rename(columns={0:'area',1:'parameter'}).dropna()

        # drop values and areas < -99999.. -9999
        df = df[df['parameter']!=-99999]
        df = df[df['parameter']!=-9999]
        df = df[df['parameter']!=-999]
        df = df[df['area']!=-99999]
        df = df[df['area']!=-9999]
        df = df[df['area']!=-999]
        
        mean = (df['parameter']/10**(self.decimals)).astype(float)
        
        #print('--> mean : ', mean)

        # get parameter classes
        classes = self.get_parameter_classes(args)
        print('--> classes : ', classes)
        print('--> classes[lower_limit].iloc[0] : ', classes['lower_limit'].iloc[0])
        print('--> classes[lower_limit].iloc[-1] : ', classes['upper_limit'].iloc[-1])
        
        print('--> np.nanmin(mean): : ', np.nanmin(mean))
        print('--> np.nanmax(mean): : ', np.nanmax(mean))

        # set lower limit for bins
        if classes['lower_limit'].iloc[0] == None:
            if classes['upper_limit'].iloc[0] > np.nanmin(mean):
                classes['lower_limit'].iloc[0] = np.nanmin(mean)-1
            else:
                classes['lower_limit'].iloc[0] = float(classes['upper_limit'].iloc[0]-1)
        # set upper limit for bins
        print('--> classes : ', classes)
        
        if classes['upper_limit'].iloc[-1] == None:
            if classes['lower_limit'].iloc[-1] < np.nanmax(mean):
                classes['upper_limit'].iloc[-1] = np.nanmax(mean)+1
            else:
                classes['upper_limit'].iloc[-1] = float(classes['lower_limit'].iloc[-1]+1)

        print('--> classes : ', classes)

        # get bins for histogram function
        classes['bins'] = classes['upper_limit']
        bins = classes['lower_limit'].astype(float).tolist()
        upper_bin = float(classes['upper_limit'].iloc[-1])
        bins.append(upper_bin)
        print('--> bins : ' + str(bins))

        # calculate histogram
        histo, bins = np.histogram(mean, bins)

        df_histo = pd.DataFrame([classes['idclass']]).T
        df_histo['count'] = histo
        
        print('--> df_histo : ', df_histo)

        return df_histo

    ## @brief Extract data of kliwes for a parameter restricted by area and time
    #
    # @return parameter_selection, numpy array
    # @return area_selection, numpy array
    def extract_parameter(self, args):

        print('--> args : ' + str(args))
        print('--> extract data')
        # get area data as list
        id_area = args['id_area']
        
        print('--> len(argsid_areadata : ' + str(len(args['id_areadata'])))
        
        if len(args['id_areadata']) > 0:
            id_areadata = list(map(int, args['id_areadata']))
        else:
            id_areadata = 'all'
        print('--> id_area : ', id_area, ', number of area data', len(id_areadata))
        # get parameter
        id_param = args['id_param']
        #print('--> id_param id : ', id_param)

        # get area
        #try:
        f_area = h5py.File(args['area_fpath'], 'r')
        ds_area = f_area['Band1']
        # select area without spatial restriction
        if id_areadata != 'all':
            area_selection = np.where(np.isin(ds_area, id_areadata), ds_area, np.nan)
        else:
            area_selection = ds_area[:]

        # restrict area selection to calculated extent
        # get area selection
        a = np.where(~np.isnan(area_selection))
        # get bounding box / extent
        min_col, max_col, min_row, max_row = np.min(a[0]), np.max(a[0]), np.min(a[1]), np.max(a[1])
        area_selection = area_selection[min_col:max_col,min_row:max_row]
        print('area_selection, shape', area_selection.shape, 'min/max col/row', min_col, max_col, min_row, max_row)
        #except:
        #    sys.exit("Unexpected error 1: " + str(sys.exc_info()))

        # get parameter
        #try:
        f_param = h5py.File(args['parameter_fpath'], 'r')
        ds_param = f_param['table']
        ds_year = f_param['year'][:]
        # extraction data for a year span
        min_year, max_year = args['start_year'], args['end_year']
        min_year_idx = np.argwhere(ds_year == min_year)[0][0]
        max_year_idx = np.argwhere(ds_year == max_year)[0][0] + 1 # including last year
        # restrict parameter dataset to spatial extent and selected years
        parameter_selection = ds_param[min_col:max_col,min_row:max_row,min_year_idx:max_year_idx]
        # add time axis to area_selection
        area_selection = area_selection[:,:,np.newaxis]
        # set nan values where area is nan
        parameter_selection = np.where(np.isnan(area_selection) == False, parameter_selection[:,:,:], np.nan)
        # parameter less than 0 is nan
        parameter_selection[np.less(parameter_selection,0.0)] = np.nan
        print('reduction of shape size', ds_param.shape, '-->', parameter_selection.shape)
        #except:
        #    sys.exit("Unexpected error 2: " + str(sys.exc_info()))

        #print('-->  parameter_selection: ',parameter_selection)
        #print('-->  area_selection[:,:,0]: ',area_selection[:,:,0])
        print('-->  ds_year[min_year_idx:max_year_idx]: ',ds_year[min_year_idx:max_year_idx])

        # return area as 2-dimensional array
        return parameter_selection, area_selection[:,:,0], ds_year[min_year_idx:max_year_idx]

    ## @brief Get parameter classes from database
    #
    # @param args
    # @returns df, pandas dataframe
    def get_parameter_classes(self, args):
        print('--> get parameter classes')
        db = pg()
        dbconf = db.dbConfig(self.conf['dbconfig'])
        dbcon = db.dbConnect()
        sql = 'SELECT idclass, lower_limit, upper_limit FROM viewer_data.class_description where idparam = ' + str(args['id_param']) + ' order by idclass'
        res = db.tblSelect(sql)
        db.dbClose()
        if res[1] > 0:
            classes = np.array(res[0])
            df_classes = pd.DataFrame([classes[:,0],classes[:,1],classes[:,2]]).T
            df_classes = df_classes.rename(columns={0:'idclass', 1:'lower_limit', 2:'upper_limit'})
        else:
            sys.exit('ERROR: no parameter classes found')

        return df_classes
    
    ## @brief Calculate raster dataset as weighted mean over area and time
    #
    # @param args
    # @param paramter, 3-dimensional array
    # @param area, 2-dimensional array
    # @returns raster, 2-dimensional array
    def get_map_data(self, args, parameter, area):

        print('--> get map data')

        # get average over time
        mean = np.nanmean(parameter, axis=2)
        print(mean.shape, area.shape, np.nanmin(mean), np.nanmax(mean))
        # get average over area
        df = pd.DataFrame(np.array([area.flatten(), mean.flatten()]).T)
        #print('--> df 1', df)
        df = df.rename(columns={0:'area',1:'parameter'}).dropna()
        #print('--> df 2', df)
        path = '/mnt/galfdaten/daten_stb/stb_sachsen/parameters/test.nc'
        f = h5py.File(path, 'w')
        ds = f.create_dataset('1', (mean.shape) , dtype=mean.dtype)
        ds[:] = mean
        #return mean
        
